---
title: "Dev-Ops for Data Scientists"
subtitle: "Overview and Best Practices"
format: 
  revealjs:
    slide-number: true
    footer: <https://github.com/posit-conf-2024/dev-ops>
    preview-links: auto
    incremental: true
    theme: [default, styles.scss]
    width: 1600
    height: 920
knitr:
  opts_chunk: 
    echo: true
execute: 
  eval: false
---

## dev-ops is...?

<br>

::: {style="font-size: 2em; color: blue;"}
‚Äú... a set of [cultural norms]{.underline}, [practices, and supporting tooling]{.underline} to help make the process of [developing and deploying software]{.underline} [smoother and lower risk]{.underline}."
:::

::: footer
Definition credit: Alex Gold, https://www.do4ds.com
:::

##  {auto-animate="true"}

::: {style="margin-top: 200px; font-size: 3em; color: blue;"}
Developing and Deploying Software
:::

## Waterfall Model of Software Development

![](assets/images/02/waterfallsldc.png)

## Where the waterfall model fails

-   **The time gap**: A developer may work on code that takes days, weeks, or even months to go into production.

-   **The personnel gap**: Developers write code, ops engineers deploy it.

-   **The tools gap**: Developers may be using a stack like Nginx, SQLite, and OS X, while the production deploy uses Apache, MySQL, and Linux.

::: footer
Credit: From the Twelve-Factor App
:::

## Agile Model

![](assets/images/02/mobius.png)

##  {auto-animate="true"}

::: {style="margin-top: 200px; font-size: 3em; color: blue;"}
Smoother and lower risk
:::

## Problems dev-ops tries to solve

![](assets/images/02/PROBLEMS.png)

##  {auto-animate="true"}

::: {style="margin-top: 200px; font-size: 3em; color: blue;"}
Cultural Norms
:::

## Instilling a sense of ...

-   collaboration
-   transparency
-   continuous feedback
-   shared responsibility
-   and most importantly...

![](assets/images/02/communicate.jpeg){fig-align="right"}

## üí¨ Discussion

::: {style="margin-top: 200px; font-size: 2em; color: blue;"}
What's the dev-ops culture like where you work?
:::

##  {auto-animate="true"}

::: {style="margin-top: 200px; font-size: 3em; color: blue;"}
Practices and supporting tooling
:::

## Proliferation of tools

![](assets/images/02/ecosystem.png)

## Best Practices \> Tools

![](assets/images/02/bestpractice.jpg)

## Best Practices from [The 12-factor App](12factor.net)

1.  **Codebase** - One codebase tracked in revision control, many deploys
2.  **Dependencies** - Explicitly declare and isolate dependencies
3.  **Config** - Store config in the environment
4.  **Backing services** - Treat backing services as attached resources
5.  **Build, release, run** - Strictly separate build and run stages
6.  **Processes** - Execute the app as one or more stateless processes
7.  Port binding - Export services via port binding
8.  Concurrency - Scale out via the process model
9.  Disposability - Maximize robustness with fast startup and graceful shutdown
10. **Dev/prod/ parity** - Keep development, staging, and production as similar as possible
11. **Logs** - Treat logs as event streams
12. **Admin processes** - Run admin/management tasks as one-off processes

## Version Control & Collaboration

![](assets/images/01/gitworkflow.png){width="681"}

::: footer
Artwork by @allison_horst
:::

## ‚úèÔ∏è Your turn {.smaller transition="slide-in"}

::: {.callout-note icon="false"}
## Activity 1: Git workflow + branching

-   initialize git locally
-   add content and merge
-   create a branch and add content
-   merge branch into main
:::

<br> <br> <br> [Activity 1 Instructions](https://pub.current.posit.team/devops-worksheet/exercise_instructions.html#fork-repository)

## Environment Management & Reproducibility

## üí¨ Discussion

::: {style="margin-top: 200px; font-size: 1.5em; color: blue;"}
What are the layers that need to be reproduced across your dev, test, and prod environments?

<br>

What's your most difficult reproducibility challenge?
:::

## Layers of reproducibility

![](assets/images/02/layerstoreproduce.png)

::: notes
-   code - scripts, configs, applications
-   Packages
-   System - r and python depend on underlying system software - for example, spatial analysis packages, or anything that requires Java - rJava
-   OS
-   Hardware - processors Intel chip, silicon chip
:::

## Packages vs. Libraries vs. Repositories

![](assets/images/02/cupcakes.png)

Think of your data science workbench as a kitchen:

-   The **repository** is the grocery store, a central place where everyone gets their packages.
-   The **library** is the pantry, where you keep your own **private** set of packages.
-   **Installation** is the shopping trip to stock your library with **packages** (e.g.ingredients) from the repository.

## Managing Environments

![](assets/images/02/repromap.png)

## Virtual Environments

![](assets/images/02/snapshotrestore.png)

::: panel-tabset
### R

```{r}
install.packages("renv")
renv::init()
renv::snapshot()
```

### Python

```{Python}
python -m venv .venv
source .venv/bin/activate
pip freeze > requirements.txt
```
:::

## ‚úèÔ∏è Your turn {.smaller transition="slide-in"}

::: {.callout-note icon="false"}
## Activity 2: Create R & Python virtual environments

-   Create renv virtual env
-   Run EDA in R env and snapshot
-   Create python venv virtual env
-   Run linear regression model in python env
-   Snapshot python requirements file
-   Push code to main in your repo
:::

<br> <br> <br> [Activity 2 Instructions](https://pub.current.posit.team/devops-worksheet/exercise_instructions.html#r)

## Continuous Integration & Delivery

![](assets/images/02/cicd2.png)

# From CI to delivery & deployment {auto-animate="true"}

![](assets/images/02/CICDauto.png)

::: footer
Image Credit: https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment
:::

## Defining Production

<br>

When other people are using your:

-   data
-   app
-   api
-   dashboard
-   model

## Production Quality

<br>

-   **Correct**: the data product works as expected
-   **Available**: unplanned outages are rare or nonexistent
-   **Safe**: data, functionality, and code are all kept safe from unauthorized users or unintended alteration
-   **Snappy**: fast response times, ability to predict needed capacity for expanded traffic
-   **Sturdy**: design and test to minimize the likelihood that changes will break things

## Building environments for CI/CD

<br>

+---------------------------------+-------------------------------------------------------------+------------------------------+
| Development                     | Testing                                                     | Production                   |
+=================================+=============================================================+==============================+
| -   Exploratory                 | -   as similar to prod as possible                          | -   automatic CD             |
|                                 |                                                             |                              |
| -   Often local machine         | -   unit & integration testing                              | -   isolated from dev & test |
|                                 |                                                             |                              |
| -   Access to R/Python Packages | -   data validation                                         | -   created with code        |
|                                 |                                                             |                              |
|                                 | -   "sandbox" with data that's as close to real as possible |                              |
+---------------------------------+-------------------------------------------------------------+------------------------------+

## Shipping to Production

![](assets/images/02/shippingextremes.png){width="563"}

::: footer
from https://blog.pragmaticengineer.com/shipping-to-production/ written and illustrated by Gergely Orosz
:::

## Importance of Testing

![](assets/images/02/bsod.jpeg)

## Types of Testing {.smaller}

+--------------------------+--------------------------------------------------------------------------------+
| Type                     | What it tests                                                                  |
+==========================+================================================================================+
| Unit                     | Do (small) individual bits of code work as they should?                        |
+--------------------------+--------------------------------------------------------------------------------+
| Integration              | Do all the pieces work together? E.g. (model + API + app +db)                  |
+--------------------------+--------------------------------------------------------------------------------+
| Functional               | Do outputs follow business logic and rules?                                    |
|                          |                                                                                |
|                          | Does the data look as it should? Are models outputting correct information     |
+--------------------------+--------------------------------------------------------------------------------+
| End-to-end               | Replicates and tests behavior from beginning to end including user interaction |
+--------------------------+--------------------------------------------------------------------------------+
| User Acceptance          | Looking for bugs, inconsistencies, errors, from end-user perspective           |
+--------------------------+--------------------------------------------------------------------------------+
| Quality Assurance        | Looking for bugs, inconsistencies, errors, from risk, product perspective      |
+--------------------------+--------------------------------------------------------------------------------+
| Performance/Optimization | Are applications reliable, fast, scalable, and responsive                      |
+--------------------------+--------------------------------------------------------------------------------+
| Smoke test/canary test   | Does the application break anything?                                           |
+--------------------------+--------------------------------------------------------------------------------+

## Github Actions for CI/CD

::: {layout-nrow="2"}
![](assets/images/02/ghdeploy.jpg){fig-align="left" width="1000"}

![](assets/images/02/ghjobssteps.png){fig-align="left" width="1000"}
:::

## üîç GHA Syntax

```{YAML}
---

name: learn-github-actions

# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request.  
on: [push]

# Groups together all the jobs that run in the `learn-github-actions` workflow
jobs:

# Defines a job named `check-bats-version`. Bats refers to Bash Automated Testing. 
  check-bats-version:

# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. 
    runs-on: ubuntu-latest

# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.
    steps:

# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.
      - uses: actions/checkout@v4

# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) 
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.
      - run: npm install -g bats

# Finally, you'll run the `bats` command with a parameter that outputs the software version.
      - run: bats -v
---
```

## Power of YAML

-   YAML Ain't Markup Language

-   communication of data between people and computers

-   human friendly

-   configures files across many execution environments

## YAML Syntax

```         
EmpRecord:  
  emp01:
    name: Michael
    job: Manager
    skills: 
      - Improv
      - Public speaking
      - People management
  emp02:
    name: Dwight
    job: Assistant to the Manager
    skills: 
      - Martial Arts
      - Beets
      - Sales
```

-   whitespace indentation denotes structure & hierarchy

-   Colons separate keys and their values

-   Dashes are used to denote a list

## Open source ecosystem of actions

-   [Github Official Actions](https://www.github.com/actions)
-   [RLib Actions](https://www.github.com/r-lib/actions)

## üîç Test and Publish to Connect

```{YAML}
---
name: test-and-connect-publish
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
 
jobs:
  test-and-connect-publish:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v2

      - uses: r-lib/actions/setup-pandoc@v2

      - uses: r-lib/actions/setup-r@v2
        with:
          r-version: 4.2.3
          use-public-rspm: true

      - uses: r-lib/actions/setup-renv@v2
          
      - name: Test Shiny App
        shell: Rscript {0}
        run: |
          shinytest2::test_app()
          
      - name: Create manifest.json
        shell: Rscript {0}
        run: |
          rsconnect::writeManifest()
          
      - name: Publish Connect content
        uses: rstudio/actions/connect-publish@main
        with:
          url: ${{ secrets.CONNECT_SERVER }}
          api-key: ${{ secrets.CONNECT_API_KEY }}
          access-type: logged_in
          dir: |
            .:/shiny-app-demo-cicd-github-actions
---
```

::: notes
Workflows can include tests, markdown renders, shell scripts, cron jobs, or deployments. They can be as simple or as complicated as you need. Open-source community provides a ton of examples of actions.
:::

## üîç Style R code

```{YAML}
---
on:
  push:
    paths: ["**.[rR]", "**.[qrR]md", "**.[rR]markdown", "**.[rR]nw", "**.[rR]profile"]

name: style.yaml

permissions: read-all

jobs:
  style:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true

      - name: Install dependencies
        uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::styler, any::roxygen2
          needs: styler

      - name: Enable styler cache
        run: styler::cache_activate()
        shell: Rscript {0}

      - name: Determine cache location
        id: styler-location
        run: |
          cat(
            "location=",
            styler::cache_info(format = "tabular")$location,
            "\n",
            file = Sys.getenv("GITHUB_OUTPUT"),
            append = TRUE,
            sep = ""
          )
        shell: Rscript {0}

      - name: Cache styler
        uses: actions/cache@v4
        with:
          path: ${{ steps.styler-location.outputs.location }}
          key: ${{ runner.os }}-styler-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-styler-
            ${{ runner.os }}-

      - name: Style
        run: styler::style_pkg()
        shell: Rscript {0}

      - name: Commit and push changes
        run: |
          if FILES_TO_COMMIT=($(git diff-index --name-only ${{ github.sha }} \
              | egrep --ignore-case '\.(R|[qR]md|Rmarkdown|Rnw|Rprofile)$'))
          then
            git config --local user.name "$GITHUB_ACTOR"
            git config --local user.email "$GITHUB_ACTOR@users.noreply.github.com"
            git commit ${FILES_TO_COMMIT[*]} -m "Style code (GHA)"
            git pull --ff-only
            git push origin
          else
            echo "No changes to commit."
          fi
---
```

## üîç Test Coverage

```{YAML}
---

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

name: test-coverage.yaml

permissions: read-all

jobs:
  test-coverage:
    runs-on: ubuntu-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - uses: actions/checkout@v4

      - uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true

      - uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::covr, any::xml2
          needs: coverage

      - name: Test coverage
        run: |
          cov <- covr::package_coverage(
            quiet = FALSE,
            clean = FALSE,
            install_path = file.path(normalizePath(Sys.getenv("RUNNER_TEMP"), winslash = "/"), "package")
          )
          covr::to_cobertura(cov)
        shell: Rscript {0}

      - uses: codecov/codecov-action@v4
        with:
          fail_ci_if_error: ${{ github.event_name != 'pull_request' && true || false }}
          file: ./cobertura.xml
          plugin: noop
          disable_search: true
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Show testthat output
        if: always()
        run: |
          ## --------------------------------------------------------------------
          find '${{ runner.temp }}/package' -name 'testthat.Rout*' -exec cat '{}' \; || true
        shell: bash

      - name: Upload test results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-test-failures
          path: ${{ runner.temp }}/package
---

```

## üîç Code Linter

```{YAML}
---

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

name: lint.yaml

permissions: read-all

jobs:
  lint:
    runs-on: ubuntu-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - uses: r-lib/actions/setup-r@v2
        with:
          use-public-rspm: true

      - uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::lintr, local::.
          needs: lint

      - name: Lint
        run: lintr::lint_package()
        shell: Rscript {0}
        env:
          LINTR_ERROR_ON_LINT: true
---
```

## ‚úèÔ∏è Your turn {.smaller transition="slide-in"}

::: {.callout-note icon="false"}
## Activity 3: Create Github Action

```         
name: GitHub Actions Demo
run-name: ${{ github.actor }} is testing out GitHub Actions üöÄ
on: [push]
jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "üéâ The job was automatically triggered by a ${{ github.event_name }} event."
      - run: echo "üêß This job is now running on a ${{ runner.os }} server hosted by GitHub!"
      - run: echo "üîé The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
      - name: Check out repository code
        uses: actions/checkout@v4
      - run: echo "üí° The ${{ github.repository }} repository has been cloned to the runner."
      - run: echo "üñ•Ô∏è The workflow is now ready to test your code on the runner."
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "üçè This job's status is ${{ job.status }}."
```
:::

<br> <br> <br> [Activity 3 Instructions](https://pub.current.posit.team/devops-worksheet/exercise_instructions.html#enable-actions-in-your-repository)

## Automation Tasks

<br> <iframe src="https://giphy.com/embed/7XsFGzfP6WmC4" width="480" height="366" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

-   Provisioning Infrastructure
-   Testing & Monitoring
-   Integration & deployment

## Tools for Automation

![](assets/images/02/Visual%20Table.jpg)

## üí¨ Discussion

::: {style="margin-top: 200px; font-size: 1.5em; color: blue;"}
Why should we automate the above tasks?

<br>

When should we NOT automate a task or process?
:::

## üîç Pulumi Example

![](assets/images/02/pulumiaws.png)

```{bash}
# Create directory and project folder
mkdir my-virtual-machine && cd my-virtual-machine && pulumi new vm-aws-python

# Create and configure a new stack
pulumi stack init dev
pulumi config set aws:region us-east-2

# Preview and run the deployment
pulumi up

# Remove the app
pulumi destroy
pulumi stack rm

```

https://github.com/pulumi/examples/tree/master/aws-py-resources

## Pre-commit hooks

::: nonincremental
-   run before every commit
-   configured in `.pre-commit-config.yaml`
-   when should we NOT use a pre-commit hook?
-   which tasks are useful to have in a pre-commit hook?
:::

::: {.callout-tip icon="false"}
Black: The uncompromising Python code formatter

*By using Black, you agree to cede control over minutiae of hand-formatting. In return, Black gives you speed, determinism, and freedom from pycodestyle nagging about formatting. You will save time and mental energy for more important matters.*
:::

## üîç Before Black

``` python
from seven_dwwarfs import Grumpy, Happy, Sleepy, Bashful, Sneezy, Dopey, Doc
x = {  'a':37,'b':42,

'c':927}

x = 123456789.123456789E123456789

if very_long_variable_name is not None and \
 very_long_variable_name.field > 0 or \
 very_long_variable_name.is_debug:
 z = 'hello '+'world'
else:
 world = 'world'
 a = 'hello {}'.format(world)
 f = rf'hello {world}'
if (this
and that): y = 'hello ''world'#FIXME: https://github.com/psf/black/issues/26
class Foo  (     object  ):
  def f    (self   ):
    return       37*-2
  def g(self, x,y=42):
      return y
def f  (   a: List[ int ]) :
  return      37-a[42-u :  y**3]
def very_important_function(template: str,*variables,file: os.PathLike,debug:bool=False,):
    """Applies `variables` to the `template` and writes to `file`."""
    with open(file, "w") as f:
     ...
# fmt: off
custom_formatting = [
    0,  1,  2,
    3,  4,  5,
    6,  7,  8,
]
# fmt: on
regular_formatting = [
    0,  1,  2,
    3,  4,  5,
    6,  7,  8,
]
```

## üîç After Black

``` python
from seven_dwwarfs import Grumpy, Happy, Sleepy, Bashful, Sneezy, Dopey, Doc

x = {"a": 37, "b": 42, "c": 927}

x = 123456789.123456789e123456789

if (
    very_long_variable_name is not None
    and very_long_variable_name.field > 0
    or very_long_variable_name.is_debug
):
    z = "hello " + "world"
else:
    world = "world"
    a = "hello {}".format(world)
    f = rf"hello {world}"
if this and that:
    y = "hello " "world"  # FIXME: https://github.com/psf/black/issues/26


class Foo(object):
    def f(self):
        return 37 * -2

    def g(self, x, y=42):
        return y


def f(a: List[int]):
    return 37 - a[42 - u : y**3]


def very_important_function(
    template: str,
    *variables,
    file: os.PathLike,
    debug: bool = False,
):
    """Applies `variables` to the `template` and writes to `file`."""
    with open(file, "w") as f:
        ...


# fmt: off
custom_formatting = [
    0,  1,  2,
    3,  4,  5,
    6,  7,  8,
]
# fmt: on
regular_formatting = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
]
```

## ‚úèÔ∏è Your turn {.smaller transition="slide-in"}

::: {.callout-note icon="false"}
## Activity 4: Build a pre-commit hook

```{bash}
# run in your bash terminal
pip install pre-commit
pip install black
```

Create a file called *.pre-commit.config.yaml* and add the following

```{bash}
repos:
  - repo: https://github.com/psf/black-pre-commit-mirror
    rev: 23.10.1
    hooks:
    - id: black
    language_version: python3.12
```

```{bash}
# run in your bash terminal
pre-commit install
```
:::

<br> <br> <br> [Activity 4 Instructions](https://pub.current.posit.team/devops-worksheet/exercise_instructions.html#activity-4-pre-commit-hooks)

## Orchestration

<br>

We want to observe...

-   Operations

-   Correctness

-   Internal state

-   Data Flow & Lineage

-   Errors

::: {.callout-note icon="false"}
*Observability is...a measure of how well you can understand and explain any state your system can get into, no matter how novel or bizarre \[...\] without needing to ship new code.*

‚Äî Honeycomb.io
:::

## Logging

-   recording execution of your code to stout or log file
-   like `print` statements but for production
-   useful for long running processes
-   when you can't simply stop the workflow

## What to log

-   functions/jobs/tests have executed correctly or incorrectly
-   error messages
-   inputs and output of a function or job
-   where things have been saved

## Log Levels

<br>

**Debug**: detail on what the code was doing

**Info**: something normal happened in the app

**Warn/Warning**: an unexpected application issue that isn‚Äôt fatal

**Error**: an issue that will make an operation not work, but that won‚Äôt crash your app.

**Critical**: an error so big that the app itself shuts down.

## üîçLogging in R

<br>

::: columns
::: {.column width="50%"}
```{r}

library(log4r)

# Configure your logging file
my_logfile = "my_logfile.txt"

# Configure your console and file layout

my_console_appender = console_appender(layout = default_log_layout())
my_file_appender = file_appender(my_logfile, append = TRUE, 
                            layout = default_log_layout())

# the log severity you are using
my_logger <- log4r::logger(threshold = "INFO", 
                appenders= list(my_console_appender,my_file_appender))

# functions that you will add into your script
log4r_info <- function() {
  log4r::info(my_logger, "Info_message.")
}

log4r_error <- function() {
  log4r::error(my_logger, "Error_message")
}

log4r_debug <- function() {
  log4r::debug(my_logger, "Debug_message")
}

```
:::

::: {.column width="50%"}
```{r}
log4r_debug() # will not trigger log entry because threshold was set to INFO

log4r_info() 
#> INFO  [2024-09-01 12:30:05] Info_message.

log4r_error() 
#> ERROR [2024-09-01 12:30:05] Error_message

readLines(my_logfile)
#> [1] "INFO  [2024-09-01 12:30:05] Info_message."
#> [2] "ERROR [2024-09-01 12:30:05] Error_message"
```
:::
:::

## üîçLogging in Python

::: columns
::: {.column width="50%"}
```{Python}
import logging

# get or create logger
logger = logging.getLogger(__name__)
# set log level
logger.setLevel(logging.WARNING)

# define file handler and set formatter
file_handler = logging.FileHandler('logfile.log')
formatter    = logging.Formatter('%(asctime)s : %(levelname)s : %(name)s : %(message)s')
file_handler.setFormatter(formatter)

# add file handler to logger
logger.addHandler(file_handler)

# Logs
logger.debug('A debug message')
logger.info('An info message')
logger.warning('Something is not right.')
logger.error('A Major error has happened.')
logger.critical('Fatal error. Cannot continue')
```
:::

::: {.column width="50%"}
```{Python}
logging.debug("debug_message") # will not trigger log entry because threshold was set to INFO

#> 2024-09-01 12:30:05,797 : WARNING : __main__ : Something is not right.
#> 2024-09-01 12:30:05,798 : ERROR : __main__ : A Major error has happened.
#> 2024-09-01 12:30:05,798 : CRITICAL : __main__ : Fatal error. Cannot continue

```
:::
:::

## Containers & Orchestration

![](assets/images/02/dockerk8s.png)

-   **Consistency:** ensure that applications run the same way across different environments.
-   **Isolation:** isolate applications and their dependencies, preventing conflicts.
-   **Portability:** run on any system that supports container, reducing "it works on my machine" issues.

## Benefits

-   allows you to package up everything you need to reproduce an environment/application
-   lightweight system without much overhead
-   share containers with colleagues without requiring them to have to set up their own local machines
-   quick testing and debugging
-   allows you to easily version snapshots of your work
-   scaling up with limited local compute
-   Create isolated environments for different experiments.

## Containerization with Docker

-   Isolation of applications inside individual OS-based environments inside virtual machines or physical servers

-   Super lightweight and fast to spin-up (much faster than a VM)

-   Made up of individual layers so its really quick to build

-   Can build isolated applications from their own image

-   Containers are immutable and ephemeral

![](assets/images/02/dockerfile-layers.png)

## Orchestration with Kubernetes

-   orchestrate multiple virtual machines or nodes to run in sync with each other

-   a set of building blocks ("primitives") that integrate well with other deployment platforms and are "extensible" through the K8s API

-   provides mechanisms to deploy, maintain and scale applications based on CPU, memory or custom metrics

## How Docker works

![](assets/images/02/lifecycle.png)

## ‚úèÔ∏è Your turn {.smaller transition="slide-in"}

::: {.callout-note icon="false"}
## Activity 5: Run docker containers

-   Run interactively
-   Run in detached mode
:::

[![](assets/images/02/file-image-container.png)Instructions here](https://pub.current.posit.team/devops-worksheet/exercise_instructions.html#activity-5-docker-run)

::: notes dockerfile - is a script of instructions for how to build an image

image - everything you need to run an application - all the layers that build the environment, dependencies, libraries, files

container - isolated instance of a running image. you can create, stop, start, restart, containers. When a container is removed/deleted any changes to its state that arent stored in some kind of persistent storage disappear. Called ephemeral container - Think of a container as a snapshot in time of a particular application.

Missing piece - repository - for images, like dockerhub, container registry cloud services, private registries

Build - Run - Push :::

## Modes for running containers

+------------------------------------------------------------+-------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Mode                                                       | Run command       | Use case                                                                                                                                                                                                           |
+============================================================+===================+====================================================================================================================================================================================================================+
| Detached                                                   | `docker run -d`   | This runs the container in the **background** so the container keeps running until the application process exits, or you stop the container. Detached mode is often used for production purposes.                  |
+------------------------------------------------------------+-------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Interactive + terminal                                     | `docker run -it`  | This runs the container in the **foreground** so you are unable to access the command prompt. Interactive mode is often used for development and testing.                                                          |
+------------------------------------------------------------+-------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Remove everything once the container is done with its task | `docker run --rm` | This mode is used on foreground containers that perform **short-term tasks** such as tests or database backups. Once it is removed anything you may have downloaded or created in the container is also destroyed. |
+------------------------------------------------------------+-------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

## Container Debugging

<br>

```{bash}
docker run -it -d ubuntu
docker container ls -a 
docker exec -it CONTAINER_ID bash

docker container run -d --name mydb \
 --name mydb \
 -e MYSQL_ROOT_PASSWORD=my-secret-pw \ 
 mysql
 
 docker container logs mydb
```

## ‚úèÔ∏è Your turn {.smaller transition="slide-in"}

::: {.callout-note icon="false"}
## Activity 6: Debug your containers

-   Use exec mode
-   Get container logs

[Instructions here](https://pub.current.posit.team/devops-worksheet/exercise_instructions.html#activity-6-debugging-containers)
:::

## Writing a Dockerfile

<br>

1\. Determine your base image

2\. Install application dependencies

3\. Copy in any relevant source code and/or binaries

4\. Configure the final image

## Writing a Dockerfile

<br> 1. Determine your base image <br>

``` python
FROM python:3.12
WORKDIR /usr/local/app
```

## Writing a Dockerfile

<br> 2. Install application dependencies <br>

``` python
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt
```

## Writing a Dockerfile

<br> 3. Copy in any relevant source code and/or binaries <br>

``` python
# Copy in the source code
COPY src ./src
EXPOSE 5000
```

## Writing a Dockerfile

<br> 4. Run/Add any additional configurations and commands <br>

``` python
# Setup an app user so the container doesn't run as the root user
RUN useradd app
USER app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]
```

## Writing a Dockerfile

``` python
FROM python:3.12
WORKDIR /usr/local/app

# Install the application dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Copy in the source code
COPY src ./src
EXPOSE 5000

# Setup an app user so the container doesn't run as the root user
RUN useradd app
USER app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]
```

## Additional Dockerfile instructions

<br>

+--------------+-------------------------------------------------------------+
| Command      | Description                                                 |
+==============+=============================================================+
| ARG          | Define variables passed at build time                       |
+--------------+-------------------------------------------------------------+
| FROM         | Base image                                                  |
+--------------+-------------------------------------------------------------+
| ENV          | Define variable                                             |
+--------------+-------------------------------------------------------------+
| COPY         | Add local file or directory                                 |
+--------------+-------------------------------------------------------------+
| RUN          | Execute commands during build process                       |
+--------------+-------------------------------------------------------------+
| CMD          | Execute command when you run container; once per Dockerfile |
+--------------+-------------------------------------------------------------+
| ENTRYPOINT   | Execute command to change default entrypoint at runtime     |
+--------------+-------------------------------------------------------------+
| USER         | Set username or ID                                          |
+--------------+-------------------------------------------------------------+
| VOLUME       | Mount host machine to container                             |
+--------------+-------------------------------------------------------------+
| EXPOSE       | Specify port pn which container listens at runtime          |
+--------------+-------------------------------------------------------------+

## Docker in CI

```{YAML}
---
         
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      -
        name: Checkout
        uses: actions/checkout@v3
      -
        name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      -
        name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/latest
---
```

## ‚úèÔ∏è Your turn {.smaller transition="slide-in"}

::: {.callout-note icon="false"}
## Activity 7: Debug your containers

-   Use exec mode
-   Get container logs

[Instructions here](https://pub.current.posit.team/devops-worksheet/exercise_instructions.html#activity-7-write-a-dockerfile)
:::

## Let's Take a Break!

![](assets/images/04/break.png)

::: footer
Artwork by @allison_horst
:::
